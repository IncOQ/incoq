# Changes from Distalgo source tree:
# - added Controller
# - changed acceptors/proposers fields to use runtimelib
#   and copy from param
# - renamed local vars to not clash in global inc module namespace

import sys
controller = import_da('controller')
import runtimelib

TIMEOUT = 1.5

class Proposer(process, controller.Controllee):
    def setup(ctl, _acceptors, nrounds):
        super().setup(ctl)
        self.acceptors = runtimelib.Set()
        self.acceptors.update(_acceptors)
        self.maj = int(len(acceptors)/2) + 1
        self.propNum = (0, self.id)
        self.propVal = self.id

    def ctl_begin(): super().ctl_begin()
    def ctl_end(): super().ctl_end()

    def main():
        ctl_begin()

        count = 0
        while count < nrounds:
            --start
            send(('Prepare', propNum), to=acceptors)
            --propose
            if await(len(setof(a, received(('Promise', _propNum, _, a)))) >= maj):
                _, pval = max(setof((votednum, votedval),
                                    received(('Promise', _propNum, (votednum, votedval), _))))
                if pval is not None:
                    propVal = pval
                send(('Propose', propNum, propVal), to=acceptors)
                if await(len(setof(a, received(('Accept', _propNum, _propVal, a)))) >= maj):
                    --end
                    output("Succeeded in proposing %r"%propVal)
                    count += 1
                    continue
                elif timeout(TIMEOUT): pass
            elif timeout(TIMEOUT): pass
            --reinit
            output("Failed ballot %s, retrying." % str(propNum))
            # Try again with a higher proposal number
            propNum = (propNum[0]+1, self.id)
        send(('Done', self.id), to=acceptors)

        ctl_end()

class Acceptor(process, controller.Controllee):
    def setup(ctl, _proposers):
        super().setup(ctl)
        self.proposers = runtimelib.Set()
        self.proposers.update(_proposers)
        self.min_propnum = (-1, self.id)

    def ctl_begin(): super().ctl_begin()
    def ctl_end(): super().ctl_end()

    def main():
        ctl_begin()

        await(each(p in proposers, has= received(('Done', p))))

        ctl_end()

    def receive(msg=('Prepare', n), from_=source):
        if (n > max(setof(propnum, sent(('Promise', propnum, _, _))) |
                    {min_propnum})):
            send(('Promise', n,
                  max(setof((mpn, vv), sent(('Accept', mpn, vv, _))) |
                      {(min_propnum, None)}),
                  self.id), to=source)

    def receive(msg=('Propose', n2, v), from_=source):
        if (n2 >= max(setof(propnum, sent(('Promise', propnum, _, _))) |
                     {min_propnum})):
            send(('Accept', n2, v, self.id), to=source)

def main():
    nproposers = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nacceptors = int(sys.argv[2]) if len(sys.argv) > 2 else 25
    nrounds = int(sys.argv[3]) if len(sys.argv) > 3 else 1

    # start the controller
    ctl = new(controller.Controller, num= 1)
    setup(ctl, (nacceptors + nproposers,))
    start(ctl)

    acceptors = new(Acceptor, num= nacceptors)
    proposers = new(Proposer, [ctl, acceptors, nrounds], num= nproposers)
    setup(acceptors, (ctl, proposers))
    start(acceptors)
    start(proposers)
