# Changes from Distalgo source tree:
# - added Controller
# - changed s field to use runtimelib and copy from param
# - wait for controller before terminating, instead of
#   peer-to-peer Done messages

import sys
controller = import_da('controller')
import runtimelib

class P(process, controller.Controllee):
    def setup(ctl, _s, n):           # pass in set of all processes
        super().setup(ctl)
        self.s = runtimelib.Set()
        self.s.update(_s)
        self.ownc = 0

    def ctl_begin(): super().ctl_begin()
    def ctl_end(): super().ctl_end()

    def cs(task):
        --request
        ownc = logical_clock()
        send(('request', ownc, self.id), to=s)    # send request to all processes
        await(each(p in s,
                   has=some(received(('ack', c, p)), has=(c > ownc))))
        --cs
        task()                  # critical section
        --release
        send(('ack', logical_clock(), self.id),
             to=setof(p, p in s,
                      has=some(received(('request', c, p)),
                               has=((c, p) >= (ownc, self.id)))))

    def receive(msg=('request', c, p)):
        if each(received(('request', _c, self.id)), has=((c, p) < (ownc, self.id))):
            send(('ack', logical_clock(), self.id), to=p)

    def main():
        ctl_begin()

        def anounce():
            output("In cs!")
        for i in range(n):
            cs(anounce)
        
        ctl_end()

def main():
    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nrounds = int(sys.argv[2]) if len(sys.argv) > 2 else 1
    config(clock='Lamport')

    # start the controller
    ctl = new(controller.Controller, num= 1)
    setup(ctl, (nprocs,))
    start(ctl)

    ps = new(P, num= nprocs)
    # setup the processes
    for p in ps: setup({p}, (ctl, ps-{p}, nrounds))
    # start the processes
    start(ps)
