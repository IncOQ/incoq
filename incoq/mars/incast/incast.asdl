module IncAST
{
    -- Unlike Python, IncAST only allows functions at the top level.
    -- Entry-point actions can be point in a main() function.
    mod = Module(fun* decls)
    
    -- Function definition omits fancy Python features like
    -- decorators, annotations, and special kinds of arguments.
    fun = (identifier name, identifier* args, stmt* body)
    
    stmt = Comment(string text)
           -- Python strips comments during lexing.
           -- We keep it in the AST.
         
         | Return(expr? value)
         
           -- Loops have no else clause.
           -- A For loop's target is just a variable.
         | For(identifier target, expr iter, stmt* body)
         | While(expr test, stmt* body)
         | If(expr test, stmt* body, stmt* orelse)
         
         | Pass | Break | Continue
         
         | Expr(expr value)
         
           -- Updates.
         
           -- Assignment to multiple targets (a = b = c) isn't allowed.
           -- Decomposing assignment (a, b = c) is a separate node.
           -- The components must be identifiers.
         | Assign(identifier target, expr value)
         | DecompAssign(identifier* vars, expr value)
         
         | SetUpdate(expr target, setupop op, expr value)
         | RelUpdate(identifier rel, setupop op, identifier elem)
         
         | DictAssign(expr target, expr key, expr value)
         | DictDelete(expr target, expr key)
         | MapAssign(identifier map, identifier key, identifier value)
         | MapDelete(identifier map, identifier key)
    
    expr = UnaryOp(unaryop op, expr operand)
         | BoolOp(boolop op, expr* values)
         | BinOp(expr left, operator op, expr right)
           -- Compare is simplified to a binary operation.
         | Compare(expr left, cmpop op, expr right)
         | IfExp(expr test, expr body, expr orelse)
         
           -- Fancy argument passing isn't supported.
           -- Call is a restricted form of GeneralCall.
         | GeneralCall(expr func, expr* args)
         | Call(identifier func, expr* args)
         
         | Num(object n)
         | Str(string s)
         | NameConstant(singleton value)
         
         | Name(identifier id)
         | List(expr* elts)
         | Tuple(expr* elts)
         | Attribute(expr value, identifier attr)
         | Subscript(expr value, expr index)
         | DictLookup(expr value, expr key, expr? default)
         
           -- Utility expressions.
         | Imgset(identifier rel, mask mask, identifier* bounds)
         
           -- Query expression.
           -- Comprehension clauses are flattened compared to Python's
           -- format, where conditions are nested underneath memberships.
         | Comp(expr resexp, clause* clauses)
    
    clause = Member(expr target, expr iter)
           | Cond(expr cond)
    
    mask = (string m)
    
    boolop = And | Or 
    
    operator = Add | Sub | Mult | Div | Mod | Pow | LShift 
             | RShift | BitOr | BitXor | BitAnd | FloorDiv
    
    unaryop = Invert | Not | UAdd | USub
    
    cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn
    
    -- New operations.
    setupop = SetAdd | SetRemove
}
